<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>gWidgetsWWW2.rapache</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>





</head>

<body>
<script type="text/javascript"> 
var student_answers = {};
var comments = {missing:"Missing answer", correct:"Correct", incorrect:"Incorrect"};
var student_id = "{{{STUDENT_ID}}}";
var page_id = "{{{PAGE_ID}}}";
</script>

<p><link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.0.4/css/bootstrap-combined.min.css" rel="stylesheet" /></p>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>

<script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.0.4/js/bootstrap.min.js"></script>

<script src="https://raw.github.com/jverzani/wmd/master/showdown.js"></script>

<script src="https://raw.github.com/jverzani/wmd/master/manipulate.js"></script>

<script>
var manipulate = function(form_id, graph_id, inputs,  expression) {

    var render = function(template, values) {
       for (value in values) {template = template.replace(new RegExp('%' + value + '%', 'g'), values[value], 'g');}
       return(template);
    }
    var rnd_id = (((1+Math.random())*0x10000)|0).toString(16).substring(1); // oops, from internet search (who?)

    var converter = new Showdown.converter();
    html = converter.makeHtml(inputs);              // make HTML from markup

    $("#" + form_id).append("<form action='#' id='" + rnd_id + "'>" + html + "</form>") ; // class='form-horizontal' gives wider layout
    $("#" + graph_id).append("<img src='data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='></img>"); //blank

    $('.noEnterSubmit').keypress(function(e){
        if ( e.which == 13 ) return e.preventDefault();
    });

    var call_expression = function(params, expression) {
        var tmp = {}
        $.each(params, function() {console.log(this.value); tmp[this.name] = this.value});
        var out = render(expression, tmp);

    $.post("https://public.opencpu.org/R/pub/base/identity/save",
           {x:out}, function(data, status, xhr) {
           var data = JSON.parse(data)
                   $("#" + graph_id).children()[0].src = "https://public.opencpu.org/R/tmp/" + data.graphs[0] + "/png"
           })
    };

    $("#" + form_id).on("change ", ':input:not([type="submit"])', function() { //change input
         call_expression($("#" + rnd_id).serializeArray(), expression);
    })
   call_expression($("#" + rnd_id).serializeArray(), expression);
}
</script>

<div id='main_message'></div>

<p><header class="jumbotron subhead"><h1>gWidgetsWWW2.rapache</h1><p class='lead'>Programming web pages with the gWidgets API</p></header></p>

<p><span><div id="navbar" class="navbar  navbar-fixed-top"><div class="navbar-inner"><ul id="navbar-header" class="nav"></ul></div></div></span><span id="subnav"></span></p>

<script>$('#navbar-header').append("<li><a href='#nav1' target='_self'>About</a></li>");</script>

<p><span><div id="nav1"></div></span><br/>
<span><div class='page-header'><h2>About</h2></div></span></p>

<p>The <code>gWidgetsWWW2.rapache</code> package implements most of the <code>gWidgets</code><br/>
API to program interactive web pages with pure <code>R</code> code.</p>

<p>The <code>gWidgets</code> API is a simple-to-learn set of constructors and<br/>
methods that make specifying the widgets for a GUI, their layout and<br/>
their interactions. The API is implemented to some degree for use with<br/>
the <code>RGtk2</code>, <code>tcltk</code> and <code>qtbase</code> packages for desktop GUIs. This<br/>
package provides the ability to serve such GUIs through the <code>apache</code><br/>
server through Jeffrey Horner&#39;s <code>rapache</code> module linking <code>R</code> with<br/>
apache.</p>

<p>Implementing the API for web programming took some iterations. The<br/>
<code>gWidgetsWWW</code> package (documented in the JSS article<br/>
<a href="http://www.jstatsoft.org/v49/i10/">http://www.jstatsoft.org/v49/i10/</a>) was the first start. That package<br/>
was rewritten to take advantage of the <code>Rook</code> package interfacing with<br/>
<code>R</code>&#39;s httpd server and incorporated reference classes instead of the<br/>
<code>proto</code> package. The result was <code>gWidgetsWWW2</code>. With that package,<br/>
serving pages locally through <code>Rook</code> works fine, but the package did<br/>
not play nicely with <code>rapache</code> to serve pages remotely. (One could use<br/>
<code>Rook</code> for this, but that method doesn&#39;t scale well.).</p>

<p>This package, <code>gWidgetsWWW2.rapache</code> then is a rewrite of the plumbing<br/>
to serve pages through apache. The main technical issue involves<br/>
having the callbacks in R share their environment amongst potentially<br/>
many <code>R</code> processes spawned by <code>apache</code>. The solution is to work really<br/>
hard to make these environments small enough that they can be<br/>
serialized/unserialized in a reasonable amount of time.</p>

<script>$('#navbar-header').append("<li><a href='#nav2' target='_self'>Basic usage</a></li>");</script>

<p><span><div id="nav2"></div></span><br/>
<span><div class='page-header'><h2>Basic usage</h2></div></span></p>

<p>Once installed (see below) the use of the package is fairly<br/>
simple. One places a script into the appropriate directory. The name<br/>
of this script then maps to the URL that will call the script. A<br/>
simple &ldquo;hello-world&rdquo; script might look like:</p>

<pre><code>w &lt;- gwindow(&#39;Hello world title&#39;)
g &lt;- gvbox(cont=w)
b &lt;- gbutton(&#39;Click me world&#39;, cont=g)
addHandlerChanged(b, function(h,...) {
  galert(&#39;Hello world!&#39;)
})
</code></pre>

<p>The above script demonstrates the main points of the package:</p>

<ul>
<li><p>A toplevel window maps to a web page (<code>gwindow</code>)</p></li>
<li><p>Containers are used to organize the layout (<code>gvbox</code> is a vertical<br/>
box container)</p></li>
<li><p>Controls are used to give the user a place to interact with<br/>
(<code>gbutton</code>)</p></li>
<li><p>dialogs can be called (<code>galert</code>)</p></li>
<li><p>interactivity is created by adding a handler<br/>
(<code>addHandlerChanged</code>). A handler, or callback, is an <code>R</code> function<br/>
that is evaluated in an event driven manner. In this case, the<br/>
&ldquo;changed&rdquo; event for a button object is triggered when the button is<br/>
clicked. The callback above produces some JavaScript that causes a<br/>
message to flash briefly on the screen.</p></li>
</ul>

<p>There are more examples in the <code>examples</code> directory of the package. A<br/>
default installation has these accessible out of the box.</p>

<script>$('#navbar-header').append("<li><a href='#nav3' target='_self'>Containers and components</a></li>");</script>

<p><span><div id="nav3"></div></span><br/>
<span><div class='page-header'><h2>Containers and components</h2></div></span></p>

<h4>Containers</h4>

<p>Containers are used to organize components (controls or other<br/>
containers). Unlike some GUI toolkits, the layout of child components<br/>
is integrated into the specification of the widget. The widget<br/>
constructors have a <code>container</code> argument where the parent is<br/>
specified. Layout arguments are given at time of construction, such as<br/>
<code>expand</code> or <code>fill</code>.</p>

<p>The package implements most &ndash; but not all &ndash; of the containers in the <code>gWidgets</code> API:</p>

<ul>
<li><p>box containers which pack children in left to right (horizontal) or<br/>
top to bottom(vertical): <code>ggroup</code>, <code>gvbox</code> (a vertical box),<br/>
<code>gframe</code> (a decorated box) and <code>gexpandgroup</code> (a box with a<br/>
disclosure icon to hide or show the contents).</p></li>
<li><p>a page layout container <code>gborderlayout</code> for placing widgets at the<br/>
center or any of the four compass directions. These panels may have<br/>
optional titles and disclosure buttons.</p></li>
<li><p>a notebook container (<code>gnotebook</code>) and the card container<br/>
(<code>gstackwidget</code>) for displaying multiple pages one at a time</p></li>
<li><p>a container for forms <code>gformlayout</code> that holds labels and controls<br/>
in an neatly organized manner.</p></li>
</ul>

<p>Not implemented are the table layout container (<code>glayout</code>) and the<br/>
paned container (<code>gpanedgroup</code>). The <code>gformlayout</code> container covers<br/>
most uses of the formal and the latter can be implemented with<br/>
<code>gborderlayout</code> (though that container does not like to be nested.)</p>

<p>Containers have just a few methods:</p>

<ul>
<li><p><code>visible&lt;-</code> can be used to adjust if the components are visible</p></li>
<li><p><code>delete</code> can be used to remove a child component. Use <code>add</code> to<br/>
restore.</p></li>
</ul>

<h4>Controls</h4>

<p>The <code>gWidgets</code> API has several controls specified. A control allows<br/>
the user to interact with the GUI or the programmer to display<br/>
information for the user. Most controls have some event that will<br/>
trigger a callback, if specified. For most controls, this event is<br/>
clear and is identified through <code>addHandlerChanged</code>. As seen, for a<br/>
button this is the clicking of the button. A few controls have more<br/>
than one event they can respond. For these, there are other<br/>
<code>addHandlerXXX</code> methods.</p>

<p>The basic controls are:</p>

<ul>
<li><p>labeling controls: <code>glabel</code>, <code>gstatusbar</code>, <code>ghtml</code>, <code>gseparator</code></p></li>
<li><p>action controls: <code>gbutton</code>, <code>gmenu</code> (but there is no<br/>
<code>gtoolbar</code>). These can be configured with sharable <code>gaction</code><br/>
instances.</p></li>
<li><p>text controls: <code>gedit</code> (single line) and <code>gtext</code> (multi-line)</p></li>
<li><p>selection controls: <code>gcheckbox</code>, <code>gradio</code>, <code>gcheckboxgroup</code>,<br/>
<code>gcombobox</code>, <code>gtable</code> (with <code>selection=&quot;checkbox&quot;</code>), <code>gslider</code>,<br/>
<code>gspinbutton</code></p></li>
<li><p>table displays: <code>gtable</code> (<code>gdf</code> is not (yet) implemented in<br/>
<code>gWidgetsWWW2.rapache</code> but is in <code>gWidgetsWWW2</code>)</p></li>
<li><p>graphics controls: <code>gimage</code>, <code>gcanvas</code>, <code>gsvg</code></p></li>
<li><p><code>gpanel</code> for incorporating external JavaScript libraries</p></li>
<li><p><code>gfile</code> for uploading files</p></li>
</ul>

<p>Implemented in <code>gWidgetsWWW2</code> but not (yet) in <code>gWidgetsWWW2.rapache</code><br/>
are <code>gtree</code>, <code>ggooglemaps</code>, and <code>gdf</code>.</p>

<p>The main widget methods are</p>

<ul>
<li><p><code>svalue</code> and <code>svalue&lt;-</code> for getting and setting the widget&#39;s main property</p></li>
<li><p><code>[</code> and <code>[&lt;-</code> for accessing the items that selection can occur from<br/>
(for the selection widgets). For such widgets, the S3 methods<br/>
<code>names</code>, <code>length</code> and <code>dim</code> are typically implemented.</p></li>
<li><p><code>enabled&lt;-</code> to change is a widget is sensitive to user input</p></li>
<li><p><code>visible&lt;-</code> to change some visibility property of the widget. (There<br/>
are many overloads, but the default is to specify if a widget is<br/>
shown or hidden.)</p></li>
<li><p><code>tooltip&lt;-</code> to specify a tooltip when the mouse hovers over the widget.</p></li>
</ul>

<script>$('#navbar-header').append("<li><a href='#nav4' target='_self'>Handlers</a></li>");</script>

<p><span><div id="nav4"></div></span><br/>
<span><div class='page-header'><h2>Handlers</h2></div></span></p>

<p>The interactivity of the GUI is controlled by assigning callbacks (or<br/>
handlers) to events. The methods <code>addHandlerXXX</code> are used for<br/>
this. The generic call is <code>addHandlerChanged</code> which calls the callback<br/>
after the &ldquo;typical&rdquo; event. Some widgets may have more than one event<br/>
associated to it.</p>

<p>All widgets with a state have a transport handler defined for it that<br/>
copies changes in the GUI back to the R process.</p>

<p>As such, these callbacks happen often. Each callback requires the<br/>
handling R process to unserialize an environment, call the handler,<br/>
then serialize the environment. This should happen quickly. To make<br/>
this the case, the environment must be kept small. (In <code>gWidgetsWWW2</code><br/>
it was seen that environments with reference classes do not serialize<br/>
small and so this took far too long.) To ensure that a few compromises<br/>
are needed:</p>

<ul>
<li><p>you should avoid reference classes</p></li>
<li><p>you will need to load packages in the handler call. Packages<br/>
attached during a script (not loaded when <code>rapache</code> is) are not<br/>
recorded or restored when the serialization takes place.</p></li>
</ul>

<p>By employing these, the response time for handling an event was kept<br/>
down to between 30 and 100ms. Not great, but acceptable. We don&#39;t try<br/>
to track keystrokes in <code>gedit</code> or all updates for the <code>gslider</code><br/>
widget, but otherwise, most things work with this response time.</p>

<h4>gtimer</h4>

<p>The <code>gtimer</code> constructor can be used to call a handler after some<br/>
prescribed period of time. The call can be repeated (the default) or<br/>
be <code>one.shot</code>. This can be useful, say, if a long running process is<br/>
implemented. The user can interact with multiple R processes, so even<br/>
if one is tied up on a long computation, the interface should still be<br/>
usable. The <code>gtimer</code> constructor should be able to poll until the<br/>
process is complete to carry back the results to the browser.</p>

<p>The <code>manipulate</code> example shows one use of <code>gtimer</code> that unfortunately<br/>
has no better idiom within this framework. That example has several<br/>
comboboxes. The value of a combobox is only available after the data<br/>
is loaded. This is done asynchronously. As such, the initial graphic<br/>
can not be made until the comboboxes are loaded. But there is no hook<br/>
(in <code>gWidgetsWWW2.rapache</code>) to allow the graphic call to happen until<br/>
after that event. Instead, we just use a one-shot timer with a<br/>
heuristically chosen delay to pause before making the call to create<br/>
the initial graphic.</p>

<script>$('#navbar-header').append("<li><a href='#nav5' target='_self'>Graphics</a></li>");</script>

<p><span><div id="nav5"></div></span><br/>
<span><div class='page-header'><h2>Graphics</h2></div></span></p>

<p>The display of graphics has several different options:</p>

<ul>
<li><p>one can display images created through the <code>png</code> driver, say, with<br/>
the <code>gimage</code> widget</p></li>
<li><p>one can display svg files created with the <code>svg</code> driver (or others)<br/>
with the <code>gsvg</code> widget</p></li>
<li><p>one can use the <code>canvas</code> package to display graphics through<br/>
<code>gcanvas</code>.</p></li>
</ul>

<p>The <code>gcanvas</code> solution is best for quickly refreshing a graph produced<br/>
with R&#39;s base graphics. It does not work with lattice graphics or<br/>
<code>ggplot2</code>.</p>

<p>The <code>gsvg</code> solution is arguably the best looking, but flickers when<br/>
the graphic is refreshed making it not such a great choice for<br/>
interactive graphics.</p>

<p>The <code>gimage</code> solution looks fine and is nearly as responsive as<br/>
<code>gcanvas</code>.</p>

<p>There are a few examples in the <code>examples</code> directory including an<br/>
implementation of RStudio&#39;s <code>manipulate</code> package which uses all three.</p>

<script>$('#navbar-header').append("<li><a href='#nav6' target='_self'>Data uploads</a></li>");</script>

<p><span><div id="nav6"></div></span><br/>
<span><div class='page-header'><h2>Data uploads</h2></div></span></p>

<p>The <code>gfile</code> constructor can be used to allow a user to upload data to<br/>
the server. A cap on the size of the upload can be specified when<br/>
<code>rapache</code> is configured.</p>

<p>The constructor call any <code>upload</code> callback when the data is<br/>
successfully uploaded. The example in the <code>examples</code> directory shows<br/>
how using <code>gstackwidget</code> a new page can be created once the data is<br/>
uploaded. Otherwise, the callback can update portions of the current<br/>
GUI to reflect the change in state.</p>

<p>The uploaded file and its name are passed back to the callback via the<br/>
<code>svalue</code> method (the path of the uploaded file) and <code>[</code> (the original<br/>
name).</p>

<script>$('#navbar-header').append("<li><a href='#nav7' target='_self'>Security</a></li>");</script>

<p><span><div id="nav7"></div></span><br/>
<span><div class='page-header'><h2>Security</h2></div></span></p>

<p>Web security is a big deal. There is the potential for malicious<br/>
intent on the part of a user. This package provides no additional<br/>
security features, but standard web safety guidelines should be<br/>
followed. (E.g., don&#39;t eval code that a user can upload, &hellip;)</p>

<script>$('#navbar-header').append("<li><a href='#nav8' target='_self'>Installation: rapache configuration</a></li>");</script>

<p><span><div id="nav8"></div></span><br/>
<span><div class='page-header'><h2>Installation: rapache configuration</h2></div></span></p>

<p>Installing this software requires a few steps:</p>

<ul>
<li>the package needs to be installed in such a way that the R process
spawned by the web server can see the package (not a local
directory)</li>
</ul>

<pre><code>require(devtools)
install_github(&quot;gWidgetsWWW2.rapache&quot;, &quot;jverzani&quot;)
</code></pre>

<ul>
<li><p>rapache must be installed (<a href="http://www.rapache.net">http://www.rapache.net</a>)</p></li>
<li><p>rapache must be configured. There are 2-3 steps:</p></li>
<li><p>The <code>mod_R.so</code> module must be loaded. Likely this is already done,<br/>
but if not you must add this to your apache configuration:</p></li>
</ul>

<pre><code>LoadModule R_module /usr/libexec/apache2/mod_R.so
</code></pre>

<ul>
<li>Some basic customization must be made. The defaults are installed
through the apache directive:</li>
</ul>

<pre><code>RSourceOnStartup(&#39;system.file(&quot;rapache&quot;, startup.R&quot;, package=&quot;gWidgetsWWW2.rapache&quot;)&#39;)
</code></pre>

<p>Alternatively, one can copy that file to the file system and modify<br/>
it. The option <code>gWidgetsWWW2.rapache::script_base</code> is the most<br/>
important, as this specifies where to look for files.</p>

<ul>
<li>The following <code>Location</code> directive is given defining the urls for your scripts:</li>
</ul>

<pre><code>&lt;Location /gw&gt;
      LimitRequestBody 1024000
        SetHandler r-handler
        ## from system.file(&quot;rapache&quot;, &quot;www2.R&quot;, package=&quot;gWidgetsWWW2.rapache&quot;)
    RFileHandler /Library/Frameworks/R.framework/Versions/2.15/Resources/library/gWidgetsWWW2.rapache/rapache/www2.R
&lt;/Location&gt;
</code></pre>

<p>The above uses the base url <code>http://your.address.com/gw</code> for accessing<br/>
scripts. (So the url <code>http://your.address.com/gw/ex.R</code> causes a search<br/>
for the file <code>ex.R</code> in the directory (directories) specified through<br/>
the option <code>gWidgetsWWW2.rapache::script_base</code>.</p>

<p>The <code>LimitRequestBody</code> limits the size of file uploads. A value of 0<br/>
is unlimited.</p>

<p>The path of the <code>www2.R</code> script comes from invoking <code>system.file</code> with<br/>
the appropriate commands. Alternatively, this script can be copied and<br/>
modified should there be a need.</p>

<p>One could add to the above apache configuration, say restricting<br/>
access using one of apache&#39;s modules.</p>

<!--- Finish this off -->

<script>
$('body').css('margin', '40px 10px');

$('body').attr('data-spy','scroll');
</script>

<div id='grade_alert'></div>

<script>

var tmp = $(".nav-tabs")

$.each(tmp, function(key, value) {
  $("#" + value.id + " a:first").tab("show")
});
 
$("#navbar").scrollspy();

$("body").attr("data-spy", "scroll");

$("[data-spy=\'scroll\']").each(function () {
  var $spy = $(this).scrollspy("refresh")
});

function comment_default(grade, stud_ans, comment, def) {
    var cmt = "";
    if(grade == 100) {
    cmt = def.correct;
    } else if(typeof(comment) != "undefined") {
    if(typeof(comment[stud_ans]) != "undefined") {
        cmt = comment[stud_ans];
    } else {
        cmt = def.incorrect;
    }
    } else {
    cmt = def.incorrect;
    }
    return cmt;
};

function comment_checkgroup(grade, stud_ans, comment, def) {
    var tmp = []; 
    $.each(stud_ans, function(key, value) {if(value !== null) tmp.push(value)});
    return comment_default(grade, tmp.sort().join("::"), comment, def);
};

function comment_numeric(grade, stud_ans, value, comment, def) {
    var cmt = "";
    if(grade == 100) {
    cmt = def.correct;
    } else if(typeof(comment) != "undefined") {
    if(stud_ans < value[0]) {
        if(typeof(comment.less) != "undefined") {
        cmt = comment.less
        } else {
        cmt = def.incorrect
        }
    } else if(stud_ans > value[1]) {
        if(typeof(comment.more) != "undefined") {
        cmt = comment.more
        } else {
        cmt = def.incorrect
        }
    }
    } else {
    cmt = def.incorrect;
    }
    return cmt;
}
function grade_radio(ans, value) {console.log(ans + ":" + value);ans=ans.replace(/\\/g, "").replace(/\s/g,"");value=value.replace(/\\/g,"").replace(/\s/g,""); return( ans == value ? 100 : 0) };
function grade_checkboxgroup(ans, value) {
  var out=[];
  $.each(ans, function(key, value) { if(value != null) { out.push(value) }});
  if(out.length != value.length) { return(0) };
  out = out.sort();
  var value = value.sort()
  for(var i=0; i < out.length; i++) {
    if(out[i] != value[i]) { return(0) }
  }
  return(100)
};
function grade_typeahead(ans, value) { return( (ans == value) ? 100 : 0 )};
function grade_combo(ans, value) { return( (ans == value) ? 100 : 0) };
function grade_numeric(ans, value) {var ans = parseFloat(ans); return( (ans >= value[0] && ans <= value[1]) ? 100 : 0) };



function submit_work(status) {
    $.ajax({
    url:"/set_answers",
    type:"POST",
    data: {
        answers:JSON.stringify(student_answers),
        status:status,
        project_id:page_id
    },
    success:function(data) {
        window.location.replace("");
    }
    });
};

function set_radio(id, value) {
  $("#" + id + " [value=" + value + "]").attr("checked", true);
};

function set_checkboxgroup(id, value) {
  $("#" + id + " [type=checkbox]").attr("checked", false);
  $.each(value, function(idx, val) {
    $("#" + id + " [value=" + val + "]").attr("checked", true)
  })
};


function set_typeahead(id, value) {
    $("#" + id).val(value)
};

function set_combo(id, value) {
    if(value.length > 0) {
    $("#" + id + " [value=" + value + "]").attr("selected", true)
    } else {
    $("#" + id)[0].selectedIndex=0;
    }

};

function set_numeric(id, value) {
    $("#" + id).val(value)
};

function set_free(id, value) {
    $("#" + id).val(value);
};

function set_answer(o) {
    var id = o.problem; 
    var value = o.answer;
    var type = o.type
    if(type == "radio") {
    set_radio(id, value)
    } else if(type == "checkbox") {
    set_checkboxgroup(id, value)
    } else if(type == "typeahead") {
    set_typeahead(id, value)
    } else if(type == "combo") {
    set_combo(id, value)
    } else if(type == "numeric") {
    set_numeric(id, value)
    } else if(type == "free") {
    set_free(id, value)
    }
};

function set_answers(status, stud_ans) {
    $.each(stud_ans, function(key, value) {
    set_answer(value);
    if(typeof(value.comment) != "undefined") {
        var cmt = '<div class="alert"><a class="close" data-dismiss="alert" href="#">×</a>' + value.comment + '</div>'
        var x =  $("#" + value.problem + "_help");
        if(x.length > 0) {
        x[0].innerHTML = cmt;
        }
        if(status == "graded") {
        var x =  $("#" + value.problem + "_comment");
        if(x.length > 0) {
            x[0].innerHTML = cmt;
        }
        }
    }
    });
};

var is_open=false;

function write_grade_table() {
    var a = student_answers;
    if(is_open) {
    $("#gradealert").alert('close');
    } else {
    $("#grade_alert").append('<div id = "fillmein"></div>');

    $("#fillmein").append('<div id="gradealert" class="alert alert-block fade in"><button class="close" data-dismiss="alert">×</button>');
    $("#gradealert").append('<h2>Congratulations, your scores so far are:</h2>');  
    $("#gradealert").append('<table id="grade_alert_table" class="table table-bordered table-striped">');
    $("#gradealert").append("</table></div>");
    
    $("#grade_alert_table").append('<thead><tr><th>Problem</th><th>Score</th><th>Comment</th></tr></thead><tbody>');

    var icon_lookup = {true:"icon-thumbs-up", false:"icon-thumbs-down", missing:"icon-warning-sign"};
    var msg_lookup = {true:"Correct", false: "Incorrect", missing:"Missing"};

    $.each(a, function() {
        $("#grade_alert_table").append("<tr>" +
                       "<td>" + 
                       "<a class='grade_clicker' href='#" + this.problem + "' target='_self'>" +
                       "Problem " + this.problem.replace("prob_", "") + "</a></td>" +
                       " <td>" + 
                       "<i class='" + icon_lookup[this.grade] + "'></i>&nbsp;" +
                       msg_lookup[this.grade] + "</td>" +
                       "<td>" + this.comment + "</td>" +
                       "</tr>");
    })
        $("#grade_alert_table").append('</tbody>');
    $(".grade_clicker").each(function() { this.onclick = function() {$("#gradealert").alert('close')}})
        $("#gradealert").alert();
    is_open = true;
    $("#gradealert").bind("closed", function() {is_open=false});
    }
};
$(document).ready(function() {
    $(".btn").button()

    var cmt_defaults={correct:comments.correct, 
              incorrect:comments.incorrect,
              missing:comments.missing
             }; 
    var fix_badge = function(key, tries, answer, comment) {
    $('#' + key + "_badge").each(function() {this.innerHTML = tries + (tries == 1 ? " try" : " tries")});
    $.each(['badge-info', 'badge-warning', 'badge-success'], function(idx, value) {
        $('#' + key + "_badge").removeClass(value)
    });
    if(answer == true) {
        $('#' + key + "_badge").addClass("badge-success");
    } else {
        $('#' + key + "_badge").addClass("badge-warning");
    };
    $('#' + key + "_help").each(function() {
        this.innerHTML=
        "<div class='alert alert-info'><a class='close' data-dismiss='alert' href='#'>×</a>" + comment + "</div>";
    });
    
    }
    var close_comment = function(key) {
    $("#" + key + "_comment > .alert").alert("close");
    };
    $("[type=\'radio\']").each(function() {
    student_answers[this.name]={problem:this.name, type:'radio', tries:0};
    this.onchange = function() {
        var key = this.name;
        var sans = this.value;
        var answer = grade_radio(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;
        student_answers[key] = {
        problem:key,
        type:'radio',
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment);
    }
    }
                  );
    $("[type=\'checkbox\']").each(function() {
    var n = $("#" + this.name + "> .checkbox").length
    var ans = {};
    for(i=1; i <= n; i++) {ans[this.name + "_" + i] = null;}
    student_answers[this.name] = {
        problem: this.name,
        type:'checkbox',
        tries:0,
        answer:ans
    };
    this.onchange = function() {
        var key = this.name;
        var sans = student_answers[key].answer;
        if(this.checked) {
        sans[this.id] = this.value;
        } else {
        sans[this.id] = null;
        }
        var answer = grade_checkboxgroup(sans, actual_answers[key].value);
        var comment = comment_checkgroup(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:'checkbox',
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".typeahead").each(function() {
    if(this.id.length > 0) {
        student_answers[this.id]={problem:this.id, type:'typeahead',  tries:0};
    }
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_typeahead(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"typeahead",
        tries:student_answers[key].tries + 1,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    
    $(".combobox").each(function() { 
    student_answers[this.id]={problem:this.id, type:'combo', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_combo(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"combo",
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".numeric_answer").each(function() {
    student_answers[this.id]={problem:this.id, type:'numeric', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_numeric(sans, actual_answers[key].value);
        var comment = comment_numeric(answer, sans, 
                      actual_answers[key].value,
                      comments[key],
                      cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"numeric",
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".free").each(function() {
    student_answers[this.id]={problem:this.id, type:'free', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        student_answers[key].answer = sans;
    };
    });

    var restore_badges = function(x) {
    $.each(x, function(key, value) {
    var badge = $("#" + key + "_badge");
    if(badge.length > 0) {
        var tries = x[key].tries;
        badge[0].innerHTML = tries + " tries"
    }
    })
}
    // get answers from server, restore
    $.ajax({
    url:"http://localhost:9000/custom/quizr/get_answers", 
    type:'POST',
    data:{ project_id:page_id}, 
    success:function(data, status, jqxhr) {
       
        if(data.status == "error") {
        return null;
        }
        
        student_answers = data.answers;
        set_answers(data.status, data.answers);
        restore_badges(student_answers);

        if(data.status == "graded") {
        // no more changes!
        $("button").addClass("disabled");
        $("button").each(function() {this.onclick=null});
            
        $.each($('[id*="prob"]'), function() {this.onchange = null});
        $("input").attr("disabled", "disabled");
        $("select").attr("disabled", "disabled");
        
        $(".badge").each(function() {this.innerHTML = "graded"});

        $("#main_message").append('<div class="alert alert-block alert-info"><a class="close" data-dismiss="alert" href="#">×</a><b>This was already graded</b>, no more changes are possible.</div>');
        }
    }
    });
});
</script>

<script>var actual_answers=[];</script>

<script>comments={ "missing": "Missing answer","correct": "Correct answer","incorrect": "Incorrect answer" };</script>

</body>

</html>
