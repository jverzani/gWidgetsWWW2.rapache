<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>gWidgetsWWW2.rapache</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>





</head>

<body>
<script type="text/javascript"> 
var student_answers = {};
var comments = {missing:"Missing answer", correct:"Correct", incorrect:"Incorrect"};
var student_id = "{{{STUDENT_ID}}}";
var page_id = "{{{PAGE_ID}}}";
</script>

<p><link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.0.4/css/bootstrap-combined.min.css" rel="stylesheet" /></p>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>

<script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.0.4/js/bootstrap.min.js"></script>

<script src="https://raw.github.com/jverzani/wmd/master/showdown.js"></script>

<script src="https://raw.github.com/jverzani/wmd/master/manipulate.js"></script>

<script>
var manipulate = function(form_id, graph_id, inputs,  expression) {

    var render = function(template, values) {
       for (value in values) {template = template.replace(new RegExp('%' + value + '%', 'g'), values[value], 'g');}
       return(template);
    }
    var rnd_id = (((1+Math.random())*0x10000)|0).toString(16).substring(1); // oops, from internet search (who?)

    var converter = new Showdown.converter();
    html = converter.makeHtml(inputs);              // make HTML from markup

    $("#" + form_id).append("<form action='#' id='" + rnd_id + "'>" + html + "</form>") ; // class='form-horizontal' gives wider layout
    $("#" + graph_id).append("<img src='data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='></img>"); //blank

    $('.noEnterSubmit').keypress(function(e){
        if ( e.which == 13 ) return e.preventDefault();
    });

    var call_expression = function(params, expression) {
        var tmp = {}
        $.each(params, function() {console.log(this.value); tmp[this.name] = this.value});
        var out = render(expression, tmp);

    $.post("https://public.opencpu.org/R/pub/base/identity/save",
           {x:out}, function(data, status, xhr) {
           var data = JSON.parse(data)
                   $("#" + graph_id).children()[0].src = "https://public.opencpu.org/R/tmp/" + data.graphs[0] + "/png"
           })
    };

    $("#" + form_id).on("change ", ':input:not([type="submit"])', function() { //change input
         call_expression($("#" + rnd_id).serializeArray(), expression);
    })
   call_expression($("#" + rnd_id).serializeArray(), expression);
}
</script>

<div id='main_message'></div>

<p><header class="jumbotron subhead"><h1>gWidgetsWWW2.rapache</h1><p class='lead'>Programming web pages with the gWidgets API</p></header></p>

<p><span><div id="navbar" class="navbar  navbar-fixed-top"><div class="navbar-inner"><ul id="navbar-header" class="nav"></ul></div></div></span><span id="subnav"></span></p>

<script>$('#navbar-header').append("<li><a href='#nav1' target='_self'>About</a></li>");</script>

<p><span><div id="nav1"></div></span>
<span><div class='page-header'><h2>About</h2></div></span></p>

<p>The <code>gWidgetsWWW2.rapache</code> package implements most of the <code>gWidgets</code>
API to program interactive web pages with pure <code>R</code> code.</p>

<p>The <code>gWidgets</code> API is a simple-to-learn set of constructors and
methods that make easy the specifying of widgets for a GUI, their
layout and their interactions. The API is implemented, to varying
degrees, for use with the <code>RGtk2</code>, <code>tcltk</code> and <code>qtbase</code> packages to
make desktop GUIs. This package provides the ability to serve such
interfacess with the <code>apache</code> web server through Jeffrey Horner&#39;s <code>rapache</code>
module linking <code>R</code> with `apache.</p>

<p>Implementing the API for web programming took some iterations. The
<code>gWidgetsWWW</code> package (documented in the JSS article
<a href="http://www.jstatsoft.org/v49/i10/">http://www.jstatsoft.org/v49/i10/</a>) was the first start. That package
was rewritten to take advantage of the <code>Rook</code> package interfacing with
<code>R</code>&#39;s httpd server and incorporated reference classes instead of the
<code>proto</code> package. The result was <code>gWidgetsWWW2</code>. With that package,
serving pages locally through <code>Rook</code> works fine, but the package did
not play nicely with <code>rapache</code> to serve pages remotely. (One could use
<code>Rook</code> for this, but that method doesn&#39;t scale well.)</p>

<p>This package, <code>gWidgetsWWW2.rapache</code>, then is a rewrite of the
plumbing to serve pages through apache and a streamlining of some of
the functionality. The main technical issue involved having the
callbacks in R share their environment amongst potentially many <code>R</code>
processes spawned by <code>apache</code>. The solution used was to work to make
these environments small enough that they can be
serialized/unserialized to disk in a reasonable amount of time.</p>

<script>$('#navbar-header').append("<li><a href='#nav2' target='_self'>Basic usage</a></li>");</script>

<p><span><div id="nav2"></div></span>
<span><div class='page-header'><h2>Basic usage</h2></div></span></p>

<p>Once installed (see below) the use of the package is fairly
simple. One places a script into the appropriate directory. The name
of this script then maps to the URL that will call the script. A
simple &quot;hello-world&quot; script might look like:</p>

<pre><code>w &lt;- gwindow(&#39;Hello world title&#39;)
g &lt;- gvbox(cont=w)
b &lt;- gbutton(&#39;Click me world&#39;, cont=g)
addHandlerChanged(b, function(h,...) {
  galert(&#39;Hello world!&#39;)
})
</code></pre>

<p>The above script demonstrates the main points of the package:</p>

<ul>
<li><p>A toplevel window maps to a web page (<code>gwindow</code>)</p></li>
<li><p>Containers are used to organize the layout (<code>gvbox</code> is a vertical
box container)</p></li>
<li><p>Controls are used to give the user a place to interact with
(<code>gbutton</code>)</p></li>
<li><p>dialogs can be called (<code>galert</code>)</p></li>
<li><p>interactivity is created by adding a handler
(<code>addHandlerChanged</code>). A handler, or callback, is an <code>R</code> function
that is evaluated in an event driven manner. In this case, the
&quot;changed&quot; event for a button object is triggered when the button is
clicked. The callback above produces some JavaScript that causes a
message to flash briefly on the screen.</p></li>
</ul>

<p>If this script is saved as <code>test.R</code> in the proper directory, then the
page will load through a url such as
<a href="http://www.youraddress.com/gw/test.R">http://www.youraddress.com/gw/test.R</a> .</p>

<p>There are more examples in the <code>examples</code> directory of the
package. A default installation has these accessible out of the box.</p>

<script>$('#navbar-header').append("<li><a href='#nav3' target='_self'>Components</a></li>");</script>

<p><span><div id="nav3"></div></span>
<span><div class='page-header'><h2>Components&nbsp;<small>containers and controls</small></h2></div></span></p>

<h3>Containers</h3>

<p>Containers are used to organize components (controls or other
containers). Unlike some GUI toolkits, the layout of child components
is integrated into the specification of the widget. The widget
constructors have a <code>container</code> argument where the parent is
specified. (E.g., above we had <code>gvbox(cont=w)</code> to next the vertical
box container inside the top-level window.) <code>Layout arguments are
given at the time of construction, such as</code>expand<code>or</code>fill`.</p>

<p>The package implements most -- but not all -- of the containers in the
<code>gWidgets</code> API:</p>

<ul>
<li><p>box containers, which pack children in left to right (horizontal) or
top to bottom (vertical): <code>ggroup</code>, <code>gvbox</code> (a vertical box),
<code>gframe</code> (a decorated box) and <code>gexpandgroup</code> (a box with a
disclosure icon to hide or show the contents).</p></li>
<li><p>a page layout container <code>gborderlayout</code> for placing widgets at the
center or any of the four compass directions. These panels may have
optional titles and disclosure buttons.</p></li>
<li><p>a notebook container (<code>gnotebook</code>) and the card container
(<code>gstackwidget</code>) for displaying multiple pages one at a time</p></li>
<li><p>a container for forms <code>gformlayout</code> that holds labels and controls
in an neatly organized manner.</p></li>
</ul>

<p>Not implemented are the table layout container (<code>glayout</code>) and the
paned container (<code>gpanedgroup</code>). The <code>gformlayout</code> container covers
most uses of the former and the latter can be implemented with
<code>gborderlayout</code> (though that container does not like to be nested
within other containers.)</p>

<p>Containers have just a few methods:</p>

<ul>
<li><p><code>visible&lt;-</code> can be used to adjust if the components are visible</p></li>
<li><p><code>delete</code> can be used to remove a child component. Use <code>add</code> to
restore.</p></li>
</ul>

<h3>Controls</h3>

<p>The <code>gWidgets</code> API has several controls specified. A control allows
the user to interact with the GUI or the programmer to display
information for the user. Most controls have some event that will
trigger a callback, if specified. For most controls, this event is
clear and is identified through the generic <code>addHandlerChanged</code>. As
seen above, for a button this is the clicking of the button. A few
controls have more than one event they can respond. For these, there
are other <code>addHandlerXXX</code> methods.</p>

<p>The basic controls are:</p>

<ul>
<li><p>labeling controls: <code>glabel</code>, <code>gstatusbar</code>, <code>ghtml</code>, <code>gseparator</code></p></li>
<li><p>action controls: <code>gbutton</code>, <code>gmenu</code> (but there is no
<code>gtoolbar</code>). These can be configured with sharable <code>gaction</code>
instances.</p></li>
<li><p>text controls: <code>gedit</code> (single line) and <code>gtext</code> (multi-line)</p></li>
<li><p>selection controls: <code>gcheckbox</code>, <code>gradio</code>, <code>gcheckboxgroup</code>,
<code>gcombobox</code>, <code>gtable</code> (with <code>selection=&quot;checkbox&quot;</code>), <code>gslider</code>,
<code>gspinbutton</code></p></li>
<li><p>table displays: <code>gtable</code> (<code>gdf</code> is not (yet) implemented in
<code>gWidgetsWWW2.rapache</code> but is in <code>gWidgetsWWW2</code>)</p></li>
<li><p>graphics displays: <code>gimage</code>, <code>gcanvas</code>, <code>gsvg</code></p></li>
<li><p><code>gpanel</code> for incorporating external JavaScript libraries</p></li>
<li><p><code>gfile</code> for uploading files</p></li>
</ul>

<p>Implemented in <code>gWidgetsWWW2</code> but not (yet) in <code>gWidgetsWWW2.rapache</code>
are <code>gtree</code>, <code>ggooglemaps</code>, and <code>gdf</code>.</p>

<p>The main widget methods are</p>

<ul>
<li><p><code>svalue</code> and <code>svalue&lt;-</code> for getting and setting the widget&#39;s main property</p></li>
<li><p><code>[</code> and <code>[&lt;-</code> for accessing the items that selection can occur from
(for the selection widgets). For such widgets, the S3 methods
<code>names</code>, <code>length</code> and <code>dim</code> are typically implemented.</p></li>
<li><p><code>enabled&lt;-</code> to change if a widget is sensitive to user input</p></li>
<li><p><code>visible&lt;-</code> to change some visibility property of the widget. (There
are many overloads, but the default is to specify if a widget is
shown or hidden. One overload is for <code>gtable</code> objects, where this
method is use to show or hide rows of the displayed data.)</p></li>
<li><p><code>tooltip&lt;-</code> to specify a tooltip when the mouse hovers over the widget.</p></li>
</ul>

<script>$('#navbar-header').append("<li><a href='#nav4' target='_self'>Handlers</a></li>");</script>

<p><span><div id="nav4"></div></span>
<span><div class='page-header'><h2>Handlers</h2></div></span></p>

<p>In addition to user-defined callbacks, all widgets with a state have a
transport handler defined for it that copies changes in the GUI back
to the <code>R</code> process. As such, these callbacks happen often. Each callback
requires the handling <code>R</code> process to unserialize an environment
containing the scope of the callback, call the handler, then serialize
the environment so it can be shared with other processes. This should
happen quickly. To make this the case, the environment must be kept
small. (In <code>gWidgetsWWW2</code> it was seen that environments with reference
classes do not serialize small and so this took far too long.) To
ensure that a few compromises are needed:</p>

<ul>
<li><p>you should avoid reference classes</p></li>
<li><p>you will need to load packages in the handler call. Packages
attached during a script (not loaded when <code>rapache</code> is) are not
recorded or restored when the serialization takes place.</p></li>
</ul>

<p>By employing these compromises, the response time for handling an
event was kept down to between 30 and 100ms. Not great, but
acceptable. We don&#39;t try to track keystrokes in <code>gedit</code> or all updates
for the <code>gslider</code> widget, but otherwise, most things work with this
response time.</p>

<h3>gtimer</h3>

<p>The <code>gtimer</code> constructor can be used to call a handler after some
prescribed period of time. The call can be repeated (the default) or
be <code>one.shot</code>. This can be useful, say, if a long running process is
implemented. The user can interact with multiple R processes, so even
if one is tied up on a long computation, the interface should still be
usable. The <code>gtimer</code> constructor should be able to poll until the
process is complete to carry back the results to the browser.</p>

<p>The <code>manipulate</code> example shows one use of <code>gtimer</code> that unfortunately
has no better idiom within this framework. That example has several
combo boxes. The value of a combobox is only available after the data
is loaded. This is done asynchronously. As such, the initial graphic
can not be made until after some unknow period. Unfortunately, there
is no hook (in <code>gWidgetsWWW2.rapache</code>) to defer the graphic call to
happen until after that event. Instead, we just use a one-shot timer
with a heuristically chosen delay to pause before making the call to
create the initial graphic.</p>

<script>$('#navbar-header').append("<li><a href='#nav5' target='_self'>Graphics</a></li>");</script>

<p><span><div id="nav5"></div></span>
<span><div class='page-header'><h2>Graphics</h2></div></span></p>

<p>The display of graphics has several different options:</p>

<ul>
<li><p>one can display images created through the <code>png</code> driver, say, with
the <code>gimage</code> widget</p></li>
<li><p>one can display svg files created with the <code>svg</code> driver (or others)
with the <code>gsvg</code> widget</p></li>
<li><p>one can use the <code>canvas</code> package to display graphics through
<code>gcanvas</code>.</p></li>
</ul>

<p>The <code>gcanvas</code> solution is best for quickly refreshing a graph produced
with R&#39;s base graphics. It does not work with lattice graphics or
<code>ggplot2</code>. One can do low level commands on the JavaScript <code>canvas</code>
object.</p>

<p>The <code>gsvg</code> solution is arguably the best looking, but flickers when
the graphic is refreshed making it not such a great choice for
interactive graphics.</p>

<p>The <code>gimage</code> solution looks fine and is nearly as responsive as
<code>gcanvas</code>.</p>

<p>There are a few examples in the <code>examples</code> directory including an
implementation of RStudio&#39;s <code>manipulate</code> package which shows how all
three can be used.</p>

<script>$('#navbar-header').append("<li><a href='#nav6' target='_self'>Data</a></li>");</script>

<p><span><div id="nav6"></div></span>
<span><div class='page-header'><h2>Data&nbsp;<small>uploads</small></h2></div></span></p>

<p>The <code>gfile</code> constructor can be used to allow a user to upload data to
the server. A cap on the size of the upload can be specified when
<code>rapache</code> is configured.</p>

<p>The widget calls any <code>upload</code> callback when the data is successfully
uploaded. The example in the <code>examples</code> directory shows how
<code>gstackwidget</code> can be used to open a new page once the data is
uploaded. Otherwise, the callback can update portions of the current
GUI to reflect the change in state.</p>

<p>The uploaded file and its name are passed back to the callback via the
<code>svalue</code> method (the path of the uploaded file) and <code>[</code> (the original
name).</p>

<script>$('#navbar-header').append("<li><a href='#nav7' target='_self'>Persistence</a></li>");</script>

<p><span><div id="nav7"></div></span>
<span><div class='page-header'><h2>Persistence</h2></div></span></p>

<p>Each time a page is loaded (even when refreshed) a new environment is
made for evaluating any callbacks. As such, the data within a page is
not persistent across page loads unless it is programmed to be so. One
can write to the file system or data base to keep values across
sessions. (The package uses <code>RSQLite</code> for this purpose. This also
means, despite cleaning up when it can, that the temporary directory
needs periodic flushing.)</p>

<script>$('#navbar-header').append("<li><a href='#nav8' target='_self'>Start up</a></li>");</script>

<p><span><div id="nav8"></div></span>
<span><div class='page-header'><h2>Start up</h2></div></span></p>

<p>The initial web page is constructed through various stages:</p>

<ul>
<li><p>a basic template is loaded</p></li>
<li><p>some large <code>JavaScript</code> libraries are loaded from CDNs. These will
be slow the first time, but should be cached so subsequent reloads
are not lengthy</p></li>
<li><p>Then a unique session ID is fetched from the server</p></li>
<li><p>Then the <code>JavaScript</code> that creates the page layout is fetched from
the server</p></li>
<li><p>Finally the browser uses this <code>JavaScript</code> to layout out the page.</p></li>
</ul>

<p>Of these, the time of the last two steps depends on the complexity of
the GUI design. In basic testing with a modest machine, each
additional widget takes about 40ms to load with a base initialization
of around 100ms (40ms is a minimum, more complex widgets will take
longer). So a not-so-complex interface with 20 or so widgets will take
around 1 second or more to fetch from the server. It may take another
second for the browser to actually process the <code>JavaScript</code>. Once
loaded the pages are fairly responsive, but the initial loading can
seem somewhat slow. A loading mask it employed to indicate that
activity is taking place.</p>

<script>$('#navbar-header').append("<li><a href='#nav9' target='_self'>JavaScript</a></li>");</script>

<p><span><div id="nav9"></div></span>
<span><div class='page-header'><h2>JavaScript</h2></div></span></p>

<p>The package uses the <code>ExtJS</code> libraries provided by <code>sencha.com</code>. These
are widely used in commercial and GPL projects. There may be some
restrictions on their use in your project, there may not be. I don&#39;t
know and don&#39;t want to. </p>

<p><code>JavaScript</code> is a language that can be used to manipulate a web page
in numerous ways. The package makes no assumption that an R user knows
<code>JavaScript</code>. Rather, its novelty is to make it easy for non-web
programmers to create web pages. That being said, there are a few ways
one with <code>JavaScript</code> knowledge can integrate that into the framework.</p>

<p>The <code>ExtJS</code> API is very rich and far more extensive than that provided
by <code>gWidgets</code>. The function <code>call_ext</code> can be used to call a method on
an object not available through the base interface.</p>

<p>Each constructor has an argument <code>ext.args</code> for passing in extra
arguments to the <code>ExtJS</code> constructor. This is specified with a list
that is converted to a <code>JavaScript</code> object through the function
<code>list_to_object</code>.</p>

<p>When a callback is run, the package creates <code>JavaScript</code> to pass back
to the browser. So a command like <code>svalue(obj) &lt;- &quot;some value&quot;</code> will
produce the appropriate <code>JavaScript</code>. Each command has its
<code>JavaScript</code> added to a queue. One can add their own <code>JavaScript</code>
commands to the queue via the <code>push_queue</code> function. For example, to
use the browsers alert dialog add this to a handler</p>

<pre><code>push_queue(&quot;alert(&#39;hello world&#39;)&quot;)
</code></pre>

<p>Finally, the <code>gpanel</code> widget does nothing more than make a <code>DIV</code> tag
on the page to be filled in by <code>JavaScript</code>. The widget allows one to
load some external <code>JavaScript</code> code asynchronously and call a handler
once loaded.</p>

<script>$('#navbar-header').append("<li><a href='#nav10' target='_self'>Security</a></li>");</script>

<p><span><div id="nav10"></div></span>
<span><div class='page-header'><h2>Security</h2></div></span></p>

<p>Web security is a big deal. There is the potential for malicious
intent on the part of a user. This package provides no additional
security features, but standard web safety guidelines should be
followed. (E.g., don&#39;t eval code that a user can upload, ...) With
the advent of cloud-based servers, you might want to deploy your
server in a stand-alone manner.</p>

<script>$('#navbar-header').append("<li><a href='#nav11' target='_self'>Debugging</a></li>");</script>

<p><span><div id="nav11"></div></span>
<span><div class='page-header'><h2>Debugging</h2></div></span></p>

<p>Debugging scripts is made more difficult, as the scripts must be
processed through the browser. Here are some useful tricks:</p>

<ul>
<li><p>A test setup is useful where a local <code>apache</code> server is used. (This
isn&#39;t helpful for windows users). Most -- but not all -- scripts can
be tested locally with <code>gWidgetsWWW2</code> under <code>Rook</code>. There are a few
differences in the API though, so this won&#39;t be fool proofed.</p></li>
<li><p>Errors are logged in apache&#39;s log file</p></li>
<li><p><code>print</code> statements do not appear in the log file, but those
generated with <code>message</code> appear in apache&#39;s log file. This can be
useful to track down issues with the script.</p></li>
<li><p>There may be errors in <code>gWidgetsWWW2.rapache</code> that are <code>JavaScript</code>
errors. Of course, the package author would love to hear about this,
so they can be fixed. But how can the end user tell? Well, a
<code>JavaScript</code> console can be used. The main browsers include these:
Chrome and Safari have built in ones available through the menu bar,
Firefox has the excellent <code>firebug</code> add on <a href="http://getfirebug.com/">http://getfirebug.com/</a> .</p></li>
</ul>

<script>$('#navbar-header').append("<li><a href='#nav12' target='_self'>Installation:</a></li>");</script>

<p><span><div id="nav12"></div></span>
<span><div class='page-header'><h2>Installation:&nbsp;<small>rapache configuration</small></h2></div></span></p>

<p>Installing this software requires a few steps:</p>

<ul>
<li>the package needs to be installed in such a way that the R process
spawned by the web server can see the package (i.e., do not use a
local directory)</li>
</ul>

<pre><code>require(devtools)
install_github(&quot;gWidgetsWWW2.rapache&quot;, &quot;jverzani&quot;)
</code></pre>

<ul>
<li><p>rapache must be installed (follow the instructions here
<a href="http://www.rapache.net">http://www.rapache.net</a>).</p></li>
<li><p>rapache must be configured. There are 2-3 steps:</p></li>
<li><p>The <code>mod_R.so</code> module must be loaded. Likely this is already done,
but if not you must add this to your apache configuration:</p></li>
</ul>

<pre><code>LoadModule R_module /usr/libexec/apache2/mod_R.so
</code></pre>

<p>The location of <code>mod_R.so</code> is system dependent, the above is a Mac
  OS X installation point.</p>

<ul>
<li>Some basic customization must be made. The defaults are installed
through the apache directive:</li>
</ul>

<pre><code>RSourceOnStartup &#39;system.file(&quot;rapache&quot;, startup.R&quot;, package=&quot;gWidgetsWWW2.rapache&quot;)&#39;
</code></pre>

<p>Alternatively, one can copy that file to the file system and modify
it. The option <code>gWidgetsWWW2.rapache::script_base</code> is the most
important, as this specifies where to look for files.</p>

<ul>
<li>The following <code>Location</code> directive is given defining the urls for your scripts:</li>
</ul>

<pre><code>&lt;Location /gw&gt;
     LimitRequestBody 1024000
     SetHandler r-handler
     ## from system.file(&quot;rapache&quot;, &quot;www2.R&quot;, package=&quot;gWidgetsWWW2.rapache&quot;)
     RFileHandler /Library/Frameworks/R.framework/Versions/2.15/Resources/library/gWidgetsWWW2.rapache/rapache/www2.R
&lt;/Location&gt;
</code></pre>

<p>The above uses the base url <code>http://your.address.com/gw/</code> for accessing
scripts. (So the url <code>http://your.address.com/gw/ex.R</code> causes a search
for the file <code>ex.R</code> in the directory (directories) specified through
the option <code>gWidgetsWWW2.rapache::script_base</code>.</p>

<p>The <code>LimitRequestBody</code> limits the size of file uploads. A value of 0
is use to indicate no limit.</p>

<p>The path of the <code>www2.R</code> script comes from invoking <code>system.file</code> with
the appropriate commands, as indicated in the comment. Alternatively,
this script can be copied and modified should there be a need.</p>

<p>One could add to the above apache configuration, say restricting
access using one of apache&#39;s modules.</p>

<p>That&#39;s it. Not much harder than installing <code>rapache</code> itself. With the
default installation, the examples directory from the package is where
URLs will be mapped to. Going to <code>http://your.address.com/gw/</code> will
open a page with links.</p>

<!--- Finish this off -->

<script>
$('body').css('margin', '40px 10px');

$('body').attr('data-spy','scroll');
</script>

<div id='grade_alert'></div>

<script>

var tmp = $(".nav-tabs")

$.each(tmp, function(key, value) {
  $("#" + value.id + " a:first").tab("show")
});
 
$("#navbar").scrollspy();

$("body").attr("data-spy", "scroll");

$("[data-spy=\'scroll\']").each(function () {
  var $spy = $(this).scrollspy("refresh")
});

function comment_default(grade, stud_ans, comment, def) {
    var cmt = "";
    if(grade == 100) {
    cmt = def.correct;
    } else if(typeof(comment) != "undefined") {
    if(typeof(comment[stud_ans]) != "undefined") {
        cmt = comment[stud_ans];
    } else {
        cmt = def.incorrect;
    }
    } else {
    cmt = def.incorrect;
    }
    return cmt;
};

function comment_checkgroup(grade, stud_ans, comment, def) {
    var tmp = []; 
    $.each(stud_ans, function(key, value) {if(value !== null) tmp.push(value)});
    return comment_default(grade, tmp.sort().join("::"), comment, def);
};

function comment_numeric(grade, stud_ans, value, comment, def) {
    var cmt = "";
    if(grade == 100) {
    cmt = def.correct;
    } else if(typeof(comment) != "undefined") {
    if(stud_ans < value[0]) {
        if(typeof(comment.less) != "undefined") {
        cmt = comment.less
        } else {
        cmt = def.incorrect
        }
    } else if(stud_ans > value[1]) {
        if(typeof(comment.more) != "undefined") {
        cmt = comment.more
        } else {
        cmt = def.incorrect
        }
    }
    } else {
    cmt = def.incorrect;
    }
    return cmt;
}
function grade_radio(ans, value) {console.log(ans + ":" + value);ans=ans.replace(/\\/g, "").replace(/\s/g,"");value=value.replace(/\\/g,"").replace(/\s/g,""); return( ans == value ? 100 : 0) };
function grade_checkboxgroup(ans, value) {
  var out=[];
  $.each(ans, function(key, value) { if(value != null) { out.push(value) }});
  if(out.length != value.length) { return(0) };
  out = out.sort();
  var value = value.sort()
  for(var i=0; i < out.length; i++) {
    if(out[i] != value[i]) { return(0) }
  }
  return(100)
};
function grade_typeahead(ans, value) { return( (ans == value) ? 100 : 0 )};
function grade_combo(ans, value) { return( (ans == value) ? 100 : 0) };
function grade_numeric(ans, value) {var ans = parseFloat(ans); return( (ans >= value[0] && ans <= value[1]) ? 100 : 0) };



function submit_work(status) {
    $.ajax({
    url:"/set_answers",
    type:"POST",
    data: {
        answers:JSON.stringify(student_answers),
        status:status,
        project_id:page_id
    },
    success:function(data) {
        window.location.replace("");
    }
    });
};

function set_radio(id, value) {
  $("#" + id + " [value=" + value + "]").attr("checked", true);
};

function set_checkboxgroup(id, value) {
  $("#" + id + " [type=checkbox]").attr("checked", false);
  $.each(value, function(idx, val) {
    $("#" + id + " [value=" + val + "]").attr("checked", true)
  })
};


function set_typeahead(id, value) {
    $("#" + id).val(value)
};

function set_combo(id, value) {
    if(value.length > 0) {
    $("#" + id + " [value=" + value + "]").attr("selected", true)
    } else {
    $("#" + id)[0].selectedIndex=0;
    }

};

function set_numeric(id, value) {
    $("#" + id).val(value)
};

function set_free(id, value) {
    $("#" + id).val(value);
};

function set_answer(o) {
    var id = o.problem; 
    var value = o.answer;
    var type = o.type
    if(type == "radio") {
    set_radio(id, value)
    } else if(type == "checkbox") {
    set_checkboxgroup(id, value)
    } else if(type == "typeahead") {
    set_typeahead(id, value)
    } else if(type == "combo") {
    set_combo(id, value)
    } else if(type == "numeric") {
    set_numeric(id, value)
    } else if(type == "free") {
    set_free(id, value)
    }
};

function set_answers(status, stud_ans) {
    $.each(stud_ans, function(key, value) {
    set_answer(value);
    if(typeof(value.comment) != "undefined") {
        var cmt = '<div class="alert"><a class="close" data-dismiss="alert" href="#">×</a>' + value.comment + '</div>'
        var x =  $("#" + value.problem + "_help");
        if(x.length > 0) {
        x[0].innerHTML = cmt;
        }
        if(status == "graded") {
        var x =  $("#" + value.problem + "_comment");
        if(x.length > 0) {
            x[0].innerHTML = cmt;
        }
        }
    }
    });
};

var is_open=false;

function write_grade_table() {
    var a = student_answers;
    if(is_open) {
    $("#gradealert").alert('close');
    } else {
    $("#grade_alert").append('<div id = "fillmein"></div>');

    $("#fillmein").append('<div id="gradealert" class="alert alert-block fade in"><button class="close" data-dismiss="alert">×</button>');
    $("#gradealert").append('<h2>Congratulations, your scores so far are:</h2>');  
    $("#gradealert").append('<table id="grade_alert_table" class="table table-bordered table-striped">');
    $("#gradealert").append("</table></div>");
    
    $("#grade_alert_table").append('<thead><tr><th>Problem</th><th>Score</th><th>Comment</th></tr></thead><tbody>');

    var icon_lookup = {true:"icon-thumbs-up", false:"icon-thumbs-down", missing:"icon-warning-sign"};
    var msg_lookup = {true:"Correct", false: "Incorrect", missing:"Missing"};

    $.each(a, function() {
        $("#grade_alert_table").append("<tr>" +
                       "<td>" + 
                       "<a class='grade_clicker' href='#" + this.problem + "' target='_self'>" +
                       "Problem " + this.problem.replace("prob_", "") + "</a></td>" +
                       " <td>" + 
                       "<i class='" + icon_lookup[this.grade] + "'></i>&nbsp;" +
                       msg_lookup[this.grade] + "</td>" +
                       "<td>" + this.comment + "</td>" +
                       "</tr>");
    })
        $("#grade_alert_table").append('</tbody>');
    $(".grade_clicker").each(function() { this.onclick = function() {$("#gradealert").alert('close')}})
        $("#gradealert").alert();
    is_open = true;
    $("#gradealert").bind("closed", function() {is_open=false});
    }
};
$(document).ready(function() {
    $(".btn").button()

    var cmt_defaults={correct:comments.correct, 
              incorrect:comments.incorrect,
              missing:comments.missing
             }; 
    var fix_badge = function(key, tries, answer, comment) {
    $('#' + key + "_badge").each(function() {this.innerHTML = tries + (tries == 1 ? " try" : " tries")});
    $.each(['badge-info', 'badge-warning', 'badge-success'], function(idx, value) {
        $('#' + key + "_badge").removeClass(value)
    });
    if(answer == true) {
        $('#' + key + "_badge").addClass("badge-success");
    } else {
        $('#' + key + "_badge").addClass("badge-warning");
    };
    $('#' + key + "_help").each(function() {
        this.innerHTML=
        "<div class='alert alert-info'><a class='close' data-dismiss='alert' href='#'>×</a>" + comment + "</div>";
    });
    
    }
    var close_comment = function(key) {
    $("#" + key + "_comment > .alert").alert("close");
    };
    $("[type=\'radio\']").each(function() {
    student_answers[this.name]={problem:this.name, type:'radio', tries:0};
    this.onchange = function() {
        var key = this.name;
        var sans = this.value;
        var answer = grade_radio(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;
        student_answers[key] = {
        problem:key,
        type:'radio',
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment);
    }
    }
                  );
    $("[type=\'checkbox\']").each(function() {
    var n = $("#" + this.name + "> .checkbox").length
    var ans = {};
    for(i=1; i <= n; i++) {ans[this.name + "_" + i] = null;}
    student_answers[this.name] = {
        problem: this.name,
        type:'checkbox',
        tries:0,
        answer:ans
    };
    this.onchange = function() {
        var key = this.name;
        var sans = student_answers[key].answer;
        if(this.checked) {
        sans[this.id] = this.value;
        } else {
        sans[this.id] = null;
        }
        var answer = grade_checkboxgroup(sans, actual_answers[key].value);
        var comment = comment_checkgroup(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:'checkbox',
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".typeahead").each(function() {
    if(this.id.length > 0) {
        student_answers[this.id]={problem:this.id, type:'typeahead',  tries:0};
    }
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_typeahead(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"typeahead",
        tries:student_answers[key].tries + 1,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    
    $(".combobox").each(function() { 
    student_answers[this.id]={problem:this.id, type:'combo', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_combo(sans, actual_answers[key].value);
        var comment = comment_default(answer, sans, comments[key], cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"combo",
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".numeric_answer").each(function() {
    student_answers[this.id]={problem:this.id, type:'numeric', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        var answer = grade_numeric(sans, actual_answers[key].value);
        var comment = comment_numeric(answer, sans, 
                      actual_answers[key].value,
                      comments[key],
                      cmt_defaults); 
        var tries = student_answers[key].tries + 1;

        student_answers[key] = {
        problem:key,
        type:"numeric",
        tries:tries,
        answer:sans,
        grade:answer,
        comment:comment
        };
        fix_badge(key, tries, answer, comment)
    }
    });
    $(".free").each(function() {
    student_answers[this.id]={problem:this.id, type:'free', tries:0};
    this.onchange = function() {
        var key = this.id;
        var sans = this.value;
        student_answers[key].answer = sans;
    };
    });

    var restore_badges = function(x) {
    $.each(x, function(key, value) {
    var badge = $("#" + key + "_badge");
    if(badge.length > 0) {
        var tries = x[key].tries;
        badge[0].innerHTML = tries + " tries"
    }
    })
}
    // get answers from server, restore
    $.ajax({
    url:"http://localhost:9000/custom/quizr/get_answers", 
    type:'POST',
    data:{ project_id:page_id}, 
    success:function(data, status, jqxhr) {
       
        if(data.status == "error") {
        return null;
        }
        
        student_answers = data.answers;
        set_answers(data.status, data.answers);
        restore_badges(student_answers);

        if(data.status == "graded") {
        // no more changes!
        $("button").addClass("disabled");
        $("button").each(function() {this.onclick=null});
            
        $.each($('[id*="prob"]'), function() {this.onchange = null});
        $("input").attr("disabled", "disabled");
        $("select").attr("disabled", "disabled");
        
        $(".badge").each(function() {this.innerHTML = "graded"});

        $("#main_message").append('<div class="alert alert-block alert-info"><a class="close" data-dismiss="alert" href="#">×</a><b>This was already graded</b>, no more changes are possible.</div>');
        }
    }
    });
});
</script>

<script>var actual_answers=[];</script>

<script>comments={ "missing": "Missing answer","correct": "Correct answer","incorrect": "Incorrect answer" };</script>

</body>

</html>
