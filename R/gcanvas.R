##' @include gcomponent.R
##' @include json.R
NULL

##' Widget containing a canvas element.
##'
##' Primarily this is a widget meant to hold a graphic produced by the
##' \pkg{canvas} package device direct.  This package provides a
##' non-interactive device for creating graphic files using
##' JavaScript. This widget allows such files to be displayed easily.
##' However, one can also write low-level canvas methods to the device
##' if desired.  When used with the \pkg{canvas} package, one passes
##' to the constructor or the \code{svalue<-} method a function that
##' has been used by the \code{canvas} device driver to store the
##' JavaScript commands representing the graphic. The basic use is in
##' an example below.
##'
##' The canvas widget can listen for mouse events, notably the click
##' event.  The first argument list for the callback passed to
##' \code{addHandlerClicked} has additional components \code{x,y}
##' containing the position of the click in ndc coordinates (in [0,1]
##' with (0,0) being lower left; \code{X,Y} the pixel position of the
##' click with (0,0) being the upper left corner; and \code{width,
##' height} containing the width and height of the canvas widget (also
##' passed in to the constructor, but this makes things convenient).
##' Conversion from ndc to "user" coordinates is done with
##' \code{grconvertXY}, but there is a catch, as one must call this
##' with an active device.  The low level canvas command allow one to
##' draw on the canvas using the pixel coordinates, which are passed
##' back as \code{X} and \code{Y}. The pixel coordinates use (0,0) as
##' the upper right. A demo shows how the low level commands can be
##' used with the mouse motion handlers to create a GUI where an
##' element can be dragged around. It isn't as responsive as one would
##' hope, as the callback into R from the browser has too much lag.
##'
##' @param f Optional. A file name containing output generated by the
##' \code{canvas} device.
##'
##' @inheritParams gwidget
##' 
##' @return an \code{GCanvas} reference class object
##'
##' @note  In the click handler one gets passed the click coordinate
##' in ndc coordinates, as this is the best the JavaScript can do, not
##' knowing the device parameters. When R gets this back it doesn't
##' have the current device to call \code{grconvertX}, say, so one
##' needs to hack in a call to the canvas device to reset the
##' parameters. See the demo examples. The examples here are more
##' basic.
##' @export
##' @examples
##' w <- gwindow()
##' gstatusbar("Powered by gWidgetsWWW2 and Rook", cont=w)
##' 
##' width <- height <- 250
##' f <- tempfile()
##' canvas(f, width=width, height=height)
##' hist(rnorm(100))
##' dev.off()
##' cnv <- gcanvas(f, container=w, width=width, height=height)
##' ## make a new new graphic
##' gbutton("refresh", cont=w, handler=function(h,...) {
##'   f <- svalue(cnv)
##'   canvas(f, width=width, height=height)
##'   hist(rnorm(100))
##'   dev.off()
##'   svalue(cnv) <- f
##' })
##'
##' ## Using canvas for drawing area using lower level canvas methods
##' w <- gwindow("gcanvas example")
##' sb <- gstatusbar("Powered by gWidgetsWWW2 and Rack", cont=w)
##' g <- ggroup(cont=w, horizontal=FALSE)
##' width <- 500; height <- 500
##' 
##' cnv <- gcanvas(width=width, height=height, cont=g)
##' 
##' started <-FALSE
##' cnv$add_handler_mouse_down(handler=function(h,...) {
##'   cnv$call_method("beginPath")
##'   cnv$call_method("moveTo", h$X, h$Y)
##'   started <<- TRUE
##' })
##' 
##' 
##' cnv$add_handler_mouse_move(handler=function(h,...) {
##'   if(started) {
##'     cnv$call_method("lineTo", h$X, h$Y)
##'     cnv$call_method("stroke")
##'   }
##' })
##' 
##' cnv$add_handler_mouse_up(handler=function(h,...) {
##'   started <<- FALSE
##' })
gcanvas <- function(f=NULL, width=480, height=400,
                    container = NULL,..., ext.args=list()) {

   
  obj <- new_item()
  class(obj) <- c("GCanvas", "GWidget", "GComponent", class(obj))


  
  ## vals
  set_vals(obj, value=f %||% "")


  ## js
  constructor <- "Ext.Panel"
  args <- list(html=sprintf("<canvas width='%s' height='%s' id='ogWidget_%s_canvas' style='position:absolute;'>xyz</canvas>", width, height, obj),
               border=TRUE,
               width=width,
               height=height,
               maxWidth=width
               )
  
  args <- merge_list(args, ext.args, add_dots(obj, ...))
  push_queue(write_ext_constructor(obj, constructor, args))
  
  
  
  ## add
  add(container, obj, ...)

  ## need to add first then draw
  if(!is.null(f) && file.exists(f))
    set_value_js(obj, f)
  
  
  obj
}

set_value_js.GCanvas <- function(obj, value) {
  ## value is a file name
  if(!file.exists(value)) {
    message("Not a valid file name:", value)
    return()
  }

  x <- readLines(value, warn=FALSE)
  push_queue(sprintf("var canvas_object = document.getElementById('%s_canvas')", o_id(obj)))
  push_queue("var ctx = canvas_object.getContext('2d');")
  push_queue("ctx.clearRect(0,0,canvas_object.width,canvas_object.height);")
  push_queue(x[-1])
}


## handlers
##' Click handler for canvas widget
##'
##' @inheritParams addHandler
##' @export
##' @rdname gWidgets-handlers
##' @method addHandlerClicked GCanvas
##' @S3method addHandlerClicked GCanvas
addHandlerClicked.GCanvas <- function(obj, handler, action=NULL, ...)
  cnv_add_handler(obj, "click", handler, action, ...)

## These may not be methods for a generic -- call with .GCanvas!
## mouse motion handlers -- do not process fast enough
## addHandlerMouseMotion.GCanvas <- function(obj, handler, action=NULL, ...)
##   cnv_add_handler(obj, "mouseover", handler, action, ...)

## addHandlerMouseMove.GCanvas <- function(obj, handler, action=NULL, ...)
##   cnv_add_handler(obj, "mousemove", handler, action, ...)

##' Default S3 method
##'
##' @inheritParams addHandler
##' @export
##' @rdname gWidgets-handlers
##' @method addHandlerMouseDown GCanvas
##' @S3method addHandlerMouseDown GCanvas
addHandlerMouseDown.GCanvas <- function(obj, handler, action=NULL, ...)
  cnv_add_handler(obj, "mousedown", handler, action, ...)

##' Default S3 method
##'
##' @inheritParams addHandler
##' @export
##' @rdname gWidgets-handlers
##' @method addHandlerMouseUp GCanvas
##' @S3method addHandlerMouseUp GCanvas
addHandlerMouseUp.GCanvas <- function(obj, handler, action=NULL, ...)
  cnv_add_handler(obj, "mouseup", handler, action, ...)



## some canvas drawing primitives

## the id. Return string
get_canvas_id <- function(obj) {
  sprintf("ogWidget_%s_canvas", obj)
}
## the context, return string
get_canvas_context <- function(obj) {
  tpl <- "document.getElementById(\"{{{canvas_id}}}\").getContext('2d')"
  canvas_id <- get_canvas_id(obj)
  whisker.render(tpl)
}
  
cnv_add_handler <- function(obj, signal, handler, action=NULL, ...) {
  n <- add_handler(obj, signal, handler, action, ...)
  if(n > 1) return()
  
  ## add js code
  tpl <- '
var ctx = document.getElementById("{{{canvas_id}}}");
ctx.addEventListener("{{{signal}}}", function(e) {
  var x = e.offsetX ? e.offsetX : e.layerX;
  var y = e.offsetY ? e.offsetY : e.layerY;
  var w = this.width; var h=this.height;                                        
  var ndcX = x/w; var ndcY = (h - y)/h;
  var params = {x:ndcX, y:ndcY,
                X:x, Y:y, lx:e.layerX,
                ly:e.layerY,
                px:e.pageX, py: e.pageY,
                cx:e.clientX, cy: e.clientY,
                ox: e.offsetX, oy: e.offsetY,
                width:this.width, height:this.height};
  Ext.Ajax.request({
    url:"{{{url}}}",
    params:{ID:ID,obj:"{{obj}}", signal:"{{signal}}" ,params:JSON.stringify(params) },
    success:eval_response
  });
});
'

  url <- make_url("ajax_call") ##"/custom/gw/ajax_call"
  canvas_id <- get_canvas_id(obj)

  push_queue(whisker.render(tpl))
}

cnv_call_method <- function(obj, method, ...) {
  tpl <- "{{{canvas_id}}}.{{{method}}}({{{params}}});"

  canvas_id <- get_canvas_context(obj)
  l <- list(...)
  if(is.null(names(l))) {
    params <- paste(lapply(l, function(x) {
      if(length(x) == 1) {
        if(is.character(x)) shQuote(x) else format(x)
      } else {
        toJSON(x)
      }
    }), collapse=", ")
  }
  else
    list_to_object(l)

  push_queue(whisker.render(tpl))
}

cnv_set_property <- function(obj, property, value) {
  
  tpl <- "{{{context}}}.{{{property}}} = {{{value}}};"

  context <- get_canvas_context(obj)
  push_queue(whisker.render(tpl))
}

cnv_set_style <- function(obj,
                           lwd=NULL, lcol=NULL, lineJoin=NULL,
                           col = NULL, alpha=NULL, ...
                           ) {
  "Set style properties"
  ## Style properties fill, lwd, ......
  if(!is.null(lwd))
    cnv_set_property(obj, "lineWidth", lwd)
  if(!is.null(lcol))
    cnv_set_property(obj, "strokeStyle", ifelse(is.numeric(lcol),
                                                sprintf("rbg(%s);", paste(lcol, collapse=",")),
                                                lcol))

  lineJoin <- lineJoin %||% "miter"
  cnv_set_property(obj, "lineJoin", shQuote(lineJoin))
  
  if(!is.null(col))
    cnv_set_property(obj, "fillStyle", ifelse(is.numeric(col),
                                              sprintf("rbg(%s);", paste(col, collapse=",")),
                                              col))
  if(!is.null(alpha))
    cnv_set_property(obj, "globalAlpha", shQuote(alpha))
}

##' Like x[i], but recycles and handles NULL
rrcycle <- function(x, i) {
  if(is.null(x)) x
  x[1 + (i-1) %% length(x)]
}

## Write R graphic primitives for canvas objects
cnv_polygon <- function(obj,
  x, y=NULL,
  ## XXX issue with col
  lwd=1,       # line width, pixels
  lcol=NULL,   # line color
  alpha = 1,   # in [0,1]
  col = NULL,  # fill color either c(R,G,B) or "#RGB"
  ...) {
  xy <- xy.coords(x, y)
  n <- length(xy$x)
  x <- c(xy$x, x[1]); y <- c(xy$y, y[1]) # append point to close

  ## curry
  . <- function(method, ...) cnv_call_method(obj, method, ...)
  set_styles <- function(...) cnv_set_style(obj, ...)

  .("save")
  set_styles(lwd=lwd, lcol=lcol, col=col, alpha=alpha)
  
  ## loop
  .("beginPath")
  for(i in seq_len(n)) {
    .("moveTo",x[i], y[i]);
    .("lineTo",x[i+1], y[i+1]);
  }
  ifelse(is.null(col),.("stroke"), .("fill"))
  .("restore")
}

cnv_lines <- function(obj,
                      x, y,
                      lwd=1,       # line width, pixels
                      lcol=NULL,   # line color
                      alpha = 1,   # in [0,1]
                      col = NULL,  # fill color either c(R,G,B) or "#RGB"
                      ...) {
  "Draw lines"
  
  ## curry
  . <- function(method, ...) cnv_call_method(obj, method, ...)
  set_styles <- function(...) cnv_set_style(obj, ...)
  
  xy <- xy.coords(x, y)
  n <- length(xy$x)
  x <- c(xy$x, x[1]); y <- c(xy$y, y[1]) # append point to close
  
  .("save")
  set_styles(lwd=lwd, lcol=lcol, col=col, alpha=alpha)
  
  .("beginPath")
  for(i in seq_len(n)) {
    if(!any(c(is.na(x[i]), is.na(y[i])))) {
      .("moveTo",x[i], y[i]);
      .("lineTo",x[i+1], y[i+1]);
    }
  }
  .("stroke")
  .("restore")
}

cnv_rect <- function(obj,
                     xleft, ybottom, xright, ytop,
                     lwd=NULL, lcol=NULL, col=NULL, alpha=NULL,
                     ...) {
  "Draw rectangles, vectorized. Rect in R is cartesian, in canvas (0,0) upper right"
   ## curry
  . <- function(method, ...) cnv_call_method(obj, method, ...)
  set_styles <- function(...) cnv_set_style(obj, ...)
  
  rect_type <- ifelse(is.null(col), "strokeRect", "fillRect")
  n <- length(xleft)

  .("save")
  
  sapply(seq_len(n), function(i) {
    .("beginPath")
    set_styles(lwd=rrcycle(lwd,i), lcol=rrcycle(lcol,i),
               col=rrcycle(col, i), alpha=rrcycle(alpha,i))
    .(rect_type, xleft[i], height - ytop[i],
      abs(xright[i] - xleft[i]), abs(ytop[i] - ybottom[i]))
                             .("stroke")
    .("restore")                             
  })
  
}

cnv_circle <- function(obj,
  x, y=NULL, r, 
  lwd=NULL, lcol=NULL, col=NULL, alpha=NULL,
  ...) {
  "Draw circles centered as (x,y) with radius r"

  ## curry
  . <- function(method, ...) cnv_call_method(obj, method, ...)
  set_styles <- function(...) cnv_set_style(obj, ...)
  
  
  xy <- xy.coords(x, y)
  n <- length(xy$x)
  r <- rep(r, len=n)
  .("save")
  
  ## loop
  for(i in seq_len(n)) {
    set_styles(lwd=rrcycle(lwd,i), lcol=rrcycle(lcol,i),
               col=rrcycle(col,i), alpha=rrcycle(alpha,i))
    .("beginPath")
    .("moveTo", x[i] + r[i], y[i])
    .("arc", x[i], y[i], r[i], 0, 2*pi)
    if(!is.null(rrcycle(col,i)))
      .("fill")
    else
      .("stroke")
    .("restore")                           
  }
}
